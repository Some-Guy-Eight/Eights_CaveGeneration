	/* just some functions and thoughts when I did not have access to my computer */

void HandleDirectionChoice() {
	
	Vector3Int startPoint = Vector3Int.zero;
	Vector3Int endPoint = Vector3Int.zero;

	// (Key) int == (int)CubeDir & (Value)float == change in magnitude
	var distanceChanges = new Dictionary<int,float>();
	distanceChanges = GetDistanceChangeByDirection(startPoint, endpoint);

	/* choose the amount of directions to choose from
	 * > 3 guarantees step will not move backwards	 
	 * >> but if inline with two axis it will favor dir by enum index
	 *
	 * > 5 covers the caveat above, but may choose dir away from end point
	 * >> small chance choice will move away from end point
	 * 
	 * > solution: as path gets closer to endPoint 
	 * >> force no moves that increase distance from end
	 * >> it will always weight the ~shortest route highest
	 * 
	 * > con: when inline with an axis
	 * >> it will stay within a 5 cell cross until it hits the end
	 *
	 * > 'fix': only have - moves fully eliminated within a threshhold
	 */

}

Dictionary<int,float> GetDistanceChangeByDirection(Vector3Int startPoint, Vector3Int endPoint) {
	
	var distanceChanges = new Dictionary<int, float>();

	float currentDistance = (endPoint- startPoint).magnitude;
	
	distanceChanges[(int)CubeDir.Right] = currentMagnitude - (endPoint- new Vector3Int(startPoint.x +1, startPoint.y, startPoint.z).magnitude;  
	distanceChanges[(int)CubeDir.Right] = currentMagnitude - (endPoint- new Vector3Int(startPoint.x -1, startPoint.y, startPoint.z).magnitude;  
	distanceChanges[(int)CubeDir.Up] = currentMagnitude - (endPoint- new Vector3Int(startPoint.x, startPoint.y+1, startPoint.z).magnitude;  
	distanceChanges[(int)CubeDir.Down] = currentMagnitude - (endPoint- new Vector3Int(startPoint.x, startPoint.y-1, startPoint.z).magnitude;  
	distanceChanges[(int)CubeDir.Forward] = currentMagnitude - (endPoint- new Vector3Int(startPoint.x, startPoint.y, startPoint.z+1).magnitude;  
	distanceChanges[(int)CubeDir.Back] = currentMagnitude - (endPoint- new Vector3Int(startPoint.x, startPoint.y, startPoint.z-1).magnitude;
	
	// shortest distances first
	distanceChanges.OrderBy(x => x.Value)

	return distanceChanges;
}
		
int? ChooseDirection(Dictionary<int,float> distanceChanges, int dirTestQuantity) {

	dirTestQuantity = Mathf.Max(distanceChanges.Count, dirTestQuantity);
	int totalTestCount = 0;
	for (int index = 0; index < dirTestQuantity; index++) {
		totalTestCount = totalTestCount + CeilToInt(distanceChanges.ElementAt(index).value);
	}
	
	int randomResult = UnityEngine.RandomRange(0, totalTestCount);
	
	for (int index = 1; index < dirTestQuantity; index++) {
		totalTestCount = CeilToInt(distanceChanges.ElementAt(index).value);
		if (totalTestCount < distanceChanges.ElementAt(index).value) {
			return index;
		}
	}
	return null;
}

