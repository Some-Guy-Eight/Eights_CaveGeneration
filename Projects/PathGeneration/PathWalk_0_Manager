using System;
using System.Collections.Generic;
using Sylves;
using UnityEngine;

namespace Tessera.CaveGeneration {
    public class PathWalkManager : MonoBehaviour {

        #region Variables
        [Header("Grid")]
        /// <summary>
        /// Original Size was 1,1,1
        /// </summary>
        [SerializeField] Vector3Int _gridCellSize;
        CubeGrid _grid;

        [Header("Main Path Walk Parameters")]
        /// <summary>
        /// Original Range was 16,16,16
        /// </summary>
        [SerializeField] Vector3Int _mainTransverseWalkRange;

        [Header("Main Weights")]
        [SerializeField] int _maxMainWeightPerDirection = 50;
        [SerializeField] int _mainPathDirectionWeight = 20;
        [SerializeField] int _mainTransverseTallyWeightFactor = 10;
        [SerializeField] int _mainPastMoveWeightFactor = 4;
        [SerializeField] int _mainOtherDirWeightFactor = 4;
        [SerializeField] int _maxMainTransverseMoveTally = 2;
        [SerializeField] int _maxMainPastMovesWeighted = 4;
        [SerializeField] int _maxMainPastMoveDirectionsStored = 4;
        /// <summary>
        /// Original ints were 6,5,4,3,2 
        /// </summary>
        [SerializeField] int[] _mainPastMoveWeightsByIndex = new int[5];

        [Header("Split Path Walk Parameters")]
        /// <summary>
        /// Original Range was 16,16,16
        /// </summary>
        [SerializeField] Vector3Int _splitTransverseWalkRange;
        [SerializeField] int _maxSplits = 2;
        [SerializeField] int _newSplitWeightFactor = 10;
        [SerializeField] int _splitTestWeightTotal = 100;
        [SerializeField] int _maxSplitTries = 4;

        [Header("Split Weights")]
        [SerializeField] int _maxSplitWeightPerDirection = 50;
        [SerializeField] int _splitPathDirectionWeight = 20;
        [SerializeField] int _splitTransverseTallyWeightFactor = 10;
        [SerializeField] int _splitPastMoveWeightFactor = 4;
        [SerializeField] int _splitOtherDirWeightFactor = 4;
        [SerializeField] int _maxSplitTransverseMoveTally = 2;
        [SerializeField] int _maxSplitPastMovesWeighted = 4;
        [SerializeField] int _maxSplitPastMoveDirectionsStored = 4;
        /// <summary>
        /// Original ints were 6,5,4,3,2 
        /// </summary>
        [SerializeField] int[] _splitPastMoveWeightsByIndex = new int[5];

        [Header("Generation")]
        [SerializeField] int _maxStepsTotal = 2000;
        [SerializeField] int _maxStepsPerUpdate = 2;
        [SerializeField] bool _doMultiplePaths = false;
        private List<MainPath> _paths = new List<MainPath>();
        GameObject _generationHolder;
        private bool _walking = false;

        [Header("Visuals")]
        [SerializeField] GameObject _mainPathVisual;
        [SerializeField] GameObject _splitPathVisual;
        MeshFilter _mainPathMeshFilter;
        MeshFilter _splitPathMeshFilter;
        Material _mainPathMaterial;
        Material _splitPathMaterial;
        #endregion

        #region Awake, Start, Update, FixedUpdate
        private void Awake() {
            PathVisualsSetUp();
            GenerationHolderSetUp();
            GridSetUp();

            /// Temp: Initialize a path for generation to start with
            InitializeMainPath((CellDir)CubeDir.Right);
        }
        private void Update() {
            HandleWalking();
        }
        #endregion

        #region Set Up
        private void PathVisualsSetUp() {
            // Main Path visuals
            if (_mainPathVisual.GetComponent<MeshFilter>() != null) {
                _mainPathMeshFilter = _mainPathVisual.GetComponent<MeshFilter>();
            } else {
                Debug.Log($"Main Path Object did not have a Mesh Filter => _pathMeshFilter not set");
            }
            if (_mainPathVisual.GetComponent<MeshRenderer>().material != null) {
                _mainPathMaterial = _mainPathVisual.GetComponent<MeshRenderer>().material;
            } else {
                Debug.Log($"Main Path Object did not have a Mesh Renderer => _pathMeshRenderer not set");
            }
            // Split Path visuals
            if (_splitPathVisual.GetComponent<MeshFilter>() != null) {
                _splitPathMeshFilter = _splitPathVisual.GetComponent<MeshFilter>();
            } else {
                Debug.Log($"Split Path Object did not have a Mesh Filter => _pathMeshFilter not set");
            }
            if (_splitPathVisual.GetComponent<MeshRenderer>().material != null) {
                _splitPathMaterial = _splitPathVisual.GetComponent<MeshRenderer>().material;
            } else {
                Debug.Log($"Split Path Object did not have a Mesh Renderer => _pathMeshRenderer not set");
            }
        }
        private void GenerationHolderSetUp() {
            _generationHolder = new GameObject {
                name = "Generation Holder"
            };
            _generationHolder.transform.position = Vector3.zero;
        }
        private void GridSetUp() {
            _grid = new CubeGrid(_gridCellSize);
        }
        #endregion

        #region Initialization
        private (CellDir, MainPath) InitializePathDirection() {

            /// TODO: Search and set path dir

            var dirAndPath = InitializeMainPath((CellDir)CubeDir.Right);
            return dirAndPath;
        }
        private (CellDir, MainPath) InitializeMainPath(CellDir dir) {

            /// TODO: Adapt to use IPath methods
            /// 

            /// TODO: find Y & Z start point & set as newCorePosition
            /// 

            /// Temp: core position set
            var newCorePosition = Vector3Int.zero;

            var newPath = new MainPath {

                /// TODO: Get Core Path based on Direction or passed in int[2]
                /// 

                Name = $"{(CubeDir) dir} & {GenerationUtils.InvertDirection((CubeDir) dir)} Path | Core ({newCorePosition.y}, {newCorePosition.z})",
                Type = PathType.Main,
                Direction = dir,
                CorePosition = newCorePosition,
                WorldPosition = newCorePosition,
                LocalPosition = newCorePosition - newCorePosition,
                PathPositionObjects = new Dictionary<Vector3Int, GameObject>(),
                DirectionalPathPositions = new Dictionary<int, Cell>(),
                SplitPathsList = new List<SplitPath>(),
                SplitObjectsDictionary = new Dictionary<Vector3Int, GameObject>(),
                PastMoveDirections = new List<CellDir>(),
                Step = 0,
                SplitPathTally = 0,
                LastSplitChangeTally = 0,
            };
            // instantiate Main Path Object
            newPath.ParentObject = _generationHolder.gameObject;
            newPath.GameObject = CreatePathObj(newPath);

            // update manager Main Path List
            _paths.Add(newPath);

            /// TODO: Pick a random transverse starting location for the '0 Step' position
            /// 

            // instantiate the '0 Step' Object & add to Main Path Dictionary
            newPath.PathPositionObjects[newCorePosition] = HandleObjectCreation((Cell) newCorePosition, newPath);

            // add to Directional Main Path Dictionary
            newPath.DirectionalPathPositions[newPath.GetPathDirectionPosition()] = (Cell)newPath.WorldPosition;
            return (dir, newPath);
        }
        private (CellDir, SplitPath) InitializeSplitPath(MainPath mainPath, Cell cell) {

            mainPath.SplitPathTally++;

            var newSplitPath = new SplitPath {

                Name = $"Split Path {mainPath.SplitPathTally} from '{mainPath.Name}'",
                ParentObject = _generationHolder.gameObject,
                ParentPath = mainPath,
                Type = PathType.Split,
                Direction = mainPath.Direction,
                PastMoveDirections = new List<CellDir>(),
                TransverseTally = 0,
                Step = 0,
            };
            newSplitPath.UpdateWorldPosition((Vector3Int)cell);
            newSplitPath.GameObject = CreatePathObj(newSplitPath);
            // update manager Main Path List
            mainPath.SplitPathsList.Add(newSplitPath);

            // create the '0 Step' Split Path Object & add to main paths split dictionary
            mainPath.SplitObjectsDictionary[newSplitPath.WorldPosition] = HandleObjectCreation(cell, newSplitPath);

            return (mainPath.Direction, newSplitPath);
        }
        #endregion

        #region Path Walk
        private void HandleWalking() {
            if (!_walking && _paths.FindLast(path => path != null).Step < _maxStepsTotal) {
                var dirAndPath = GetPathDirection();
                if (dirAndPath.Item2 != null) {
                    PathWalk(dirAndPath);
                } else {
                    Debug.Log($"Main Path returned to HandleWalking is null => Not progressing to walking");
                }
            }
        }
        private (CellDir, MainPath) GetPathDirection() {

            var lastPath = _paths[_paths.Count-1];
            var dirAndPath = (lastPath.Direction,lastPath);

            if (lastPath.Step >= _maxStepsTotal && _doMultiplePaths) {

                /// TODO: Search for new path to initialize
                /// 

                dirAndPath = InitializePathDirection();
                
            } else if (lastPath.Step >= _maxStepsTotal) {
                Debug.Log($"Move direction is full => returning null Main Path");
                return ((CellDir)CubeDir.Right,null);
            }
            return dirAndPath;
        }
        private void PathWalk(ValueTuple<CellDir, MainPath> dirAndPath) {

            int stepsThisWalk = _maxStepsPerUpdate;
            MainPath mainPath = dirAndPath.Item2;
            CellDir pathDir = dirAndPath.Item2.Direction;
            CellDir inverseDir = GenerationUtils.InvertDirection(dirAndPath.Item2.Direction);

            // set variables stored in the manager for use below
            Vector3Int localPosition = mainPath.LocalPosition;
            List<CellDir> pastMoveDirections = mainPath.PastMoveDirections;

            Vector3Int transverseWalkRange = _mainTransverseWalkRange;
            int transverseTally = mainPath.TransverseTally;
            int maxTransverseMoveTally = _maxMainTransverseMoveTally;
            int transverseTallyWeightFactor = _mainTransverseTallyWeightFactor;

            int[] pastMoveWeightsByIndex = _mainPastMoveWeightsByIndex;
            int pastMoveWeightFactor = _mainPastMoveWeightFactor;
            int maxPastMovesWeighted = _maxMainPastMovesWeighted;
            int maxWeightPerDirection = _maxMainWeightPerDirection;
            int otherDirWeightFactor = _mainOtherDirWeightFactor;

            MainPathLoop();
            SplitPathLoop();

            void MainPathLoop() {
                // Walk loop main Main Path & Split Path initiation Logic
                for (int mainDirSteps = 0; mainDirSteps < stepsThisWalk; mainDirSteps++) {
                    // set after each step
                    localPosition = mainPath.LocalPosition;
                    pastMoveDirections = mainPath.PastMoveDirections;
                    transverseTally = mainPath.TransverseTally;
                    // get direction to move
                    (CubeDir?, bool) nullableStepAndUpdatedTally = PickMoveDirection(mainPath);
                    if (nullableStepAndUpdatedTally.Item2 == true) {
                        mainPath.TransverseTally = 0;
                    }
                    if (nullableStepAndUpdatedTally.Item1 == null) {
                        Debug.Log($"Move direction is null while walking Main Path => continueing to next loop");
                        break;
                    }

                    Debug.Log($"Main Path TransverseTally == {mainPath.TransverseTally}");

                    CellDir step = (CellDir) nullableStepAndUpdatedTally.Item1;
                    if (step == pathDir) {
                        mainPath.TransverseTally = 0;
                    } else {
                        mainPath.TransverseTally++;
                    }
                    mainPath.PastMoveDirections.Insert(0, step);
                    if (mainPath.PastMoveDirections.Count > _maxMainPastMoveDirectionsStored) {
                        mainPath.PastMoveDirections.RemoveAt(_maxMainPastMoveDirectionsStored);
                    }
                    _grid.TryMove((Cell) mainPath.WorldPosition, step, out Cell newCell, out CellDir currentMoveInverseDir, out Connection connection);
                    mainPath.Step++;
                    mainPath.UpdateWorldPosition((Vector3Int)newCell);

                    var newStepObject = HandleObjectCreation(newCell, mainPath);
                    mainPath.PathPositionObjects[(Vector3Int)newCell] = newStepObject;

                    int newDirectionalPosition = mainPath.GetPathDirectionPosition((Vector3Int) newCell);

                    if (step != pathDir) {
                        // not in the main dir => increment maindDirSteps down
                        // - Makes sure the moves in the main dir are only taken into account
                        mainDirSteps--;
                    } else if (step == pathDir && !mainPath.DirectionalPathPositions.ContainsKey(newDirectionalPosition)) {
                        mainPath.DirectionalPathPositions[newDirectionalPosition] = newCell;
                    }

                    mainPath.LastSplitChangeTally++;
                    if (mainPath.SplitPathTally < _maxSplits) {
                        int newSplitWeight = mainPath.SplitPathTally * _newSplitWeightFactor;
                        int testInt = UnityEngine.Random.Range(0, _splitTestWeightTotal);

                        if (newSplitWeight < testInt) {

                            // get last main path position - 1, so the main path does not walk on the split path
                            int previousMainPathIndex = mainPath.GetPathDirectionPosition(mainPath.WorldPosition) -1;
                            if (mainPath.DirectionalPathPositions.TryGetValue(previousMainPathIndex, out Cell previousMainPathCell)) {
                                // Pick random transverse direction to walk
                                CellDir[] transverseDir = mainPath.GetTransverseDirections();
                                int randomIndex = UnityEngine.Random.Range(0, transverseDir.Length);
                                CellDir splitDir = transverseDir[randomIndex];
                                var nullableCell = FindEmptyCellForSplit(splitDir,previousMainPathCell);
                                if (nullableCell != null) {
                                    var cell = (Cell) nullableCell;
                                    mainPath.LastSplitChangeTally = 0;
                                    InitializeSplitPath(mainPath, cell);
                                    var newSplit = mainPath.SplitPathsList[mainPath.SplitPathsList.Count-1];
                                    newSplit.PastMoveDirections.Insert(0, splitDir);
                                }
                            }
                            // no valid cell was found, just move on for now and try next Main Path step
                        }
                    }
                }
            }

            void SplitPathLoop() {
                // set variables stored in manager to split set once b/c they are constant
                transverseWalkRange = _splitTransverseWalkRange;
                maxTransverseMoveTally = _maxSplitTransverseMoveTally;
                otherDirWeightFactor = _splitOtherDirWeightFactor;
                maxWeightPerDirection = _maxSplitWeightPerDirection;
                maxPastMovesWeighted = _maxSplitPastMovesWeighted;
                pastMoveWeightFactor = _splitPastMoveWeightFactor;
                transverseTallyWeightFactor = _splitTransverseTallyWeightFactor;
                pastMoveWeightsByIndex = _splitPastMoveWeightsByIndex;

                // Walk loop => branch split
                Queue<SplitPath> splitRemovalQueue = new Queue<SplitPath>();
                foreach (SplitPath splitPath in mainPath.SplitPathsList) {
                    // end split if inside a mainPath,or other split cell
                    if (mainPath.PathPositionObjects.TryGetValue(splitPath.WorldPosition, out GameObject stepGameObject)) {
                        // in a cell occupied by a MainPath => end SplitPath
                        // > Remove conflicting Split Path GameObject
                        // > Remove Split Path from SplitPositionObjects Dictionary
                        // > Enqueue Split Path to remove from SplitPaths List after loop
                        GameObject splitObject = mainPath.SplitObjectsDictionary[splitPath.WorldPosition];
                        Destroy(splitObject);
                        mainPath.SplitObjectsDictionary.Remove(splitPath.WorldPosition);
                        splitRemovalQueue.Enqueue(splitPath);
                    } else {
                        // no path in PathPositions => iterate through walk
                        // > get last main path position - 1
                        // > Split path will stop before current main path position
                        // >> prevents main path from walking on split path
                        int branchStepsThisWalk = Mathf.Abs(mainPath.GetPathDirectionPosition() - mainPath.GetPathDirectionPosition(splitPath.WorldPosition)) -1;
                        for (int branchSplitSteps = 0; branchSplitSteps < branchStepsThisWalk; branchSplitSteps++) {
                            // set after each step
                            localPosition = splitPath.LocalPosition;
                            pastMoveDirections = splitPath.PastMoveDirections;
                            transverseTally = splitPath.TransverseTally;

                            /// TODO: add in a method that will decrease the branch range over time
                            /// > will effectively limit how long a branch remains split from the main path
                            /// 

                            (CubeDir?, bool) nullableStepAndUpdatTallyBool = PickMoveDirection(splitPath);
                            if (nullableStepAndUpdatTallyBool.Item2 == true) {
                                splitPath.TransverseTally = 0;
                            }
                            if (nullableStepAndUpdatTallyBool.Item1 == null) {
                                Debug.Log($"Move direction is null while walking Split Path => continueing to next loop");
                                break;
                            }

                            CellDir step = (CellDir) nullableStepAndUpdatTallyBool.Item1;
                            if (step == pathDir) {
                                splitPath.TransverseTally = 0;
                            } else {
                                splitPath.TransverseTally++;
                            }
                            splitPath.PastMoveDirections.Insert(0, step);
                            if (splitPath.PastMoveDirections.Count > _maxSplitPastMoveDirectionsStored) {
                                splitPath.PastMoveDirections.RemoveAt(_maxSplitPastMoveDirectionsStored);
                            }
                            _grid.TryMove((Cell) splitPath.WorldPosition, step, out Cell newCell, out CellDir currentMoveInverseDir, out Connection connection);
                            if (mainPath.PathPositionObjects.TryGetValue((Vector3Int) newCell, out GameObject mainPathGameObject)) {
                                // moving into Main Path Cell
                                // > enqueue Split Path for removal and end this loop
                                splitRemovalQueue.Enqueue(splitPath);
                                // end for loop for this split path
                                break;
                            } else if (mainPath.SplitObjectsDictionary.TryGetValue((Vector3Int) newCell, out GameObject contridictingSplitPath)) {
                                // moving into other Split Path Cell
                                // > enqueue Split Path for removal and end this loop
                                splitRemovalQueue.Enqueue(splitPath);
                                // end for loop for this split path
                                break;
                            } else {
                                splitPath.Step++;
                                splitPath.UpdateWorldPosition((Vector3Int) newCell);

                                HandleObjectCreation(newCell, splitPath);
                                if (step != pathDir) {
                                    // not in the main dir => increment maindDirSteps down
                                    // - Makes sure the moves in the main dir are only taken into account
                                    branchSplitSteps--;
                                }
                                Debug.Log($"{splitPath.Name} Transverse Tally == {splitPath.TransverseTally}");
                            }
                        }
                    }
                }
                // Remove all splits that merged from Queue
                for (int processed = 0; processed < splitRemovalQueue.Count; processed++) {
                    //var splitPathToRemoveAndDestroy = splitRemovalQueue.Dequeue();
                    //mainPath.SplitPathsList.Remove(splitPathToRemoveAndDestroy);
                    mainPath.SplitPathsList.Remove(splitRemovalQueue.Dequeue());
                    mainPath.SplitPathTally--;
                }
            }

            (CubeDir?,bool) PickMoveDirection(IPath path) {
                bool resetTally = false;
                if (transverseTally >= maxTransverseMoveTally) {
                    resetTally = true;
                    return ((CubeDir)pathDir, resetTally);
                }
                var directionsWeights = new int[6];

                // Set weight for possible moves based on LocalPosition & Tally counts
                directionsWeights[(int)CubeDir.Right] = Mathf.Min((-localPosition.x + transverseWalkRange.x) * otherDirWeightFactor, maxWeightPerDirection);
                directionsWeights[(int)CubeDir.Left] = Mathf.Min((localPosition.x + transverseWalkRange.x) * otherDirWeightFactor, maxWeightPerDirection);
                directionsWeights[(int)CubeDir.Up] = Mathf.Min((-localPosition.y + transverseWalkRange.y) * otherDirWeightFactor, maxWeightPerDirection);
                directionsWeights[(int)CubeDir.Down] = Mathf.Min((localPosition.y + transverseWalkRange.y) * otherDirWeightFactor, maxWeightPerDirection);
                directionsWeights[(int)CubeDir.Forward] = Mathf.Min((-localPosition.z + transverseWalkRange.z) * otherDirWeightFactor, maxWeightPerDirection);
                directionsWeights[(int)CubeDir.Back] = Mathf.Min((localPosition.z + transverseWalkRange.z) * otherDirWeightFactor, maxWeightPerDirection);

                // Adjust weight weight values past move dir
                for (int index = 0; index < maxPastMovesWeighted; index++) {
                    if (pastMoveDirections.Count > index) {
                        switch ((CubeDir) pastMoveDirections[index]) {
                            case CubeDir.Right:
                                directionsWeights[(int)CubeDir.Right] = Mathf.Max(directionsWeights[(int)CubeDir.Right] - (pastMoveWeightsByIndex[index] * pastMoveWeightFactor), 0); break;
                            case CubeDir.Left:
                                directionsWeights[(int) CubeDir.Left] = Mathf.Max(directionsWeights[(int)CubeDir.Left] - (pastMoveWeightsByIndex[index] * pastMoveWeightFactor), 0); break;
                            case CubeDir.Up:
                                directionsWeights[(int) CubeDir.Up] = Mathf.Max(directionsWeights[(int)CubeDir.Up] - (pastMoveWeightsByIndex[index] * pastMoveWeightFactor), 0); break;
                            case CubeDir.Down:
                                directionsWeights[(int) CubeDir.Down] = Mathf.Max(directionsWeights[(int)CubeDir.Down] - (pastMoveWeightsByIndex[index] * pastMoveWeightFactor), 0); break;
                            case CubeDir.Forward:
                                directionsWeights[(int) CubeDir.Forward] = Mathf.Max(directionsWeights[(int)CubeDir.Forward] - (pastMoveWeightsByIndex[index] * pastMoveWeightFactor), 0); break;
                            case CubeDir.Back:
                                directionsWeights[(int)CubeDir.Back] = Mathf.Max(directionsWeights[(int)CubeDir.Back] - (pastMoveWeightsByIndex[index] * pastMoveWeightFactor), 0); break;
                        }
                    }
                }
                // Set main dir value based off of transverse movements
                directionsWeights[(int)pathDir] = Mathf.Min(_mainPathDirectionWeight + (transverseTally * transverseTallyWeightFactor), maxWeightPerDirection);
                // remove inverse main dir from pool
                directionsWeights[(int)inverseDir] = 0;
                // remove inverse direction of last move direction from pool
                // > stops from walking back on self
                if (pastMoveDirections.Count > 0) {
                    directionsWeights[(int) GenerationUtils.InvertDirection(pastMoveDirections[0])] = 0;
                }

                /// Adjust weights based on distance from main path cell to favor moving towards main path
                /// > use step count to increase liklihood of moving towards main path
                /// >> as step count increases => more likely to move towards main path
                if (path.GetPathType() == PathType.Split) {
                    Vector3Int positionRelativeToMainPath = path.GetLocalPosition();
                    // if any direction is outside of Split Path Range => move towards path
                    // * should not need to worry axis of path, b/c relative axis position will always be 0
                    if (positionRelativeToMainPath.x > transverseWalkRange.x) {
                        Debug.Log($"+X distance too far");
                        return (CubeDir.Left, resetTally);
                    } else if (positionRelativeToMainPath.x < -transverseWalkRange.x) {
                        Debug.Log($"-X distance too far");
                        return (CubeDir.Right, resetTally);
                    }  else if (positionRelativeToMainPath.y > transverseWalkRange.y) {
                        Debug.Log($"+Y distance too far");
                        return (CubeDir.Down, resetTally);
                    } else if (-positionRelativeToMainPath.y < -transverseWalkRange.y) {
                        Debug.Log($"-Y distance too far");
                        return (CubeDir.Up, resetTally);
                    } else if (positionRelativeToMainPath.z > transverseWalkRange.z) {
                        Debug.Log($"+Z distance too far");
                        return (CubeDir.Back, resetTally);
                    } else if (-positionRelativeToMainPath.z < -transverseWalkRange.z) {
                        Debug.Log($"-Z distance too far");
                        return (CubeDir.Forward, resetTally);
                    }
                }

                // Pick from weighted count
                int totalWeightedCount = 0;
                // add up all values in directionWeights
                for (int dir = 0; dir < directionsWeights.Length; dir++) {
                    totalWeightedCount = totalWeightedCount + directionsWeights[dir];
                }
                int randomInt = UnityEngine.Random.Range(0, totalWeightedCount);
                int currentMaxExclusive = directionsWeights[(int) CubeDir.Right];

                if (randomInt < currentMaxExclusive) {
                    return (CubeDir.Right, resetTally);
                } else {
                    currentMaxExclusive = currentMaxExclusive + directionsWeights[(int) CubeDir.Left];
                }
                if (randomInt < currentMaxExclusive) {
                    return (CubeDir.Left, resetTally);
                } else {
                    currentMaxExclusive = currentMaxExclusive + directionsWeights[(int) CubeDir.Up];
                }
                if (randomInt < currentMaxExclusive) {
                    return (CubeDir.Up, resetTally);
                } else {
                    currentMaxExclusive = currentMaxExclusive + directionsWeights[(int) CubeDir.Down];
                }
                if (randomInt < currentMaxExclusive) {
                    return (CubeDir.Down, resetTally);
                } else {
                    currentMaxExclusive = currentMaxExclusive + directionsWeights[(int) CubeDir.Forward];
                }
                if (randomInt < currentMaxExclusive) {
                    return (CubeDir.Forward, resetTally);
                } else {
                    currentMaxExclusive = currentMaxExclusive + directionsWeights[(int) CubeDir.Back];
                }
                if (randomInt < currentMaxExclusive) {
                    return (CubeDir.Back, resetTally);
                }
                Debug.Log($"number was never included during move direction picking => returning null CellDir");
                return (null, resetTally);

            }

            Cell? FindEmptyCellForSplit(CellDir dir, Cell cell){
                Cell? nullableCell = null;
                Cell currentTryCell = cell;
                // repeat steps until empty cell is found
                for (int splitTries = 0; splitTries < _maxSplitTries; splitTries++) {
                    _grid.TryMove(currentTryCell, dir, out Cell newCell, out CellDir currentMoveInverseDir, out Connection connection);
                    if (!mainPath.PathPositionObjects.ContainsKey((Vector3Int)newCell)) {
                        // Found cell w/o Main Path => check split path cells
                        if (!mainPath.SplitObjectsDictionary.ContainsKey((Vector3Int)newCell)) {
                            // Found empty cell => break & return cell
                            nullableCell = newCell;
                            break;
                        }
                    }
                }
                return nullableCell;
            }
        }
        #endregion

        #region Oject Creation
        private GameObject HandleObjectCreation(Cell cell, IPath path) {

            /// TODO: Set up enqueue system
            ///

            /// TODO: Send to proper Instantiation Method
            /// 

            /// Temp: Instantiate basic obj
            return CreateStepObject(cell, path);

        }
        private GameObject CreateStepObject(Cell cell, IPath path) {
            var type = path.GetPathType();
            var stepObj = new GameObject {
                name = $"{type} Step {path.GetStep()} | Cell {cell}",
            };
            stepObj.transform.position = (Vector3Int)cell;
            stepObj.transform.rotation = Quaternion.identity;
            stepObj.transform.parent = path.GetGameObject().transform;

            var filter = stepObj.AddComponent<MeshFilter>();
            var renderer = stepObj.AddComponent<MeshRenderer>();
            if (type == PathType.Main) {
                filter.mesh = _mainPathMeshFilter.mesh;
                renderer.material = _mainPathMaterial;
            } else if (type == PathType.Split) {
                filter.mesh = _splitPathMeshFilter.mesh;
                renderer.material = _splitPathMaterial;
            }
            return stepObj; 
        }
        private GameObject CreatePathObj(IPath path) {
            var pathObj = new GameObject {
                name = path.GetName()
            };
            pathObj.transform.position = path.GetParentObject().transform.position;
            pathObj.transform.rotation = Quaternion.identity;
            pathObj.transform.parent = path.GetParentObject().transform;

            return pathObj;
        }
        #endregion
    }
}
